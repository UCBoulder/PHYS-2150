<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EQE Measurement - PHYS 2150</title>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="css/theme.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/eqe-layout.css">

    <!-- Plotly.js for interactive plots (local copy) -->
    <script src="js/plotly.min.js"></script>

    <!-- Qt WebChannel -->
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <!-- Shared modules -->
    <script src="js/api.js"></script>
    <script src="js/theme.js"></script>
    <script src="js/modals.js"></script>
</head>
<body class="dark-mode eqe-body">
    <div class="eqe-app">
        <!-- Header Row -->
        <div class="eqe-header">
            <h1>EQE Measurement</h1>
            <div class="header-actions">
                <span id="pixel-label" class="text-muted">Pixel: --</span>
                <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                    <svg id="sun-icon" class="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg id="moon-icon" class="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Top Section: Parameters + Progress -->
        <div class="top-section">
            <div class="params-panel">
                <div class="panel-title">Measurement Parameters</div>
                <div class="params-grid">
                    <div class="param-field">
                        <label>Start (nm)</label>
                        <input type="number" id="start-wavelength" value="350" step="10">
                    </div>
                    <div class="param-field">
                        <label>End (nm)</label>
                        <input type="number" id="end-wavelength" value="750" step="10">
                    </div>
                    <div class="param-field">
                        <label>Step (nm)</label>
                        <input type="number" id="step-size" value="10" step="1">
                    </div>
                    <div class="param-field">
                        <label>Cell Number</label>
                        <input type="text" id="cell-number" placeholder="e.g. 140" maxlength="3">
                    </div>
                </div>
            </div>

            <div class="progress-panel">
                <div class="panel-title">Status</div>
                <div class="progress-content">
                    <div class="progress-status" id="progress-status">Ready</div>
                    <div class="progress-bar-container" id="progress-bar-row">
                        <div class="progress-bar">
                            <div class="progress-bar-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="progress-percent" id="progress-percent">0%</span>
                    </div>
                    <div class="live-reading hidden" id="live-reading">
                        <span id="live-value">--</span> nA
                    </div>
                </div>
            </div>
        </div>

        <!-- Device Status Row with Monochromator Controls -->
        <div class="device-status-row">
            <div class="device-item">
                <span class="device-dot disconnected" id="picoscope-dot"></span>
                <span class="device-name">PicoScope:</span>
                <span class="device-status" id="picoscope-status">Connecting...</span>
            </div>
            <div class="device-item">
                <span class="device-dot disconnected" id="mono-dot"></span>
                <span class="device-name">Monochromator:</span>
                <span class="device-status" id="mono-status">Connecting...</span>
            </div>
            <div class="device-item">
                <span class="device-dot disconnected" id="power-dot"></span>
                <span class="device-name">Power Meter:</span>
                <span class="device-status" id="power-status">Connecting...</span>
            </div>

            <div class="mono-controls-inline">
                <span class="mono-state"><span id="mono-wavelength">--</span> nm</span>
                <span class="shutter-badge closed" id="shutter-badge">Closed</span>
                <input type="number" id="wavelength-input" placeholder="nm" min="200" max="1200">
                <button class="btn btn-secondary btn-small" onclick="goToWavelength()">Go</button>
                <button class="btn btn-secondary btn-small" id="shutter-btn" onclick="toggleShutter()">Open</button>
                <button class="btn btn-secondary btn-small" onclick="alignMonochromator()">Align</button>
            </div>
        </div>

        <!-- Three Plots Row -->
        <div class="plots-row">
            <div class="plot-panel">
                <div class="plot-title">Incident Light Power</div>
                <div class="plot-container">
                    <div id="power-plot" class="plot"></div>
                </div>
            </div>

            <div class="plot-panel">
                <div class="plot-title">PV Current</div>
                <div class="plot-container">
                    <div id="current-plot" class="plot"></div>
                </div>
            </div>

            <div class="plot-panel">
                <div class="plot-title">Phase Response and Sine Fit</div>
                <div class="plot-container">
                    <div id="phase-plot" class="plot"></div>
                </div>
                <div class="stats-row hidden" id="stats-row">
                    <span class="stat-item">n: <span class="stat-value" id="stats-n">--</span></span>
                    <span class="stat-item">outliers: <span class="stat-value" id="stats-outliers">0</span></span>
                    <span class="stat-item">CV: <span class="stat-value" id="stats-cv">--%</span></span>
                    <span class="quality-badge" id="stats-quality">--</span>
                </div>
            </div>
        </div>

        <!-- Buttons Row -->
        <div class="buttons-row">
            <button class="btn btn-primary" id="power-btn" onclick="startPowerMeasurement()">
                Start Power Measurement
            </button>
            <button class="btn btn-primary" id="current-btn" onclick="startCurrentMeasurement()">
                Start Current Measurement
            </button>
            <button class="btn btn-danger" id="stop-btn" onclick="stopMeasurement()" disabled>
                Stop
            </button>
            <button class="btn btn-secondary" id="save-btn" onclick="saveData()" disabled>
                Save Data
            </button>
            <button class="btn btn-secondary" id="live-btn" onclick="toggleLiveMonitor()">
                Live Monitor
            </button>
        </div>
    </div>

    <!-- Cell Number Modal (shown on startup) -->
    <div class="modal-overlay" id="cell-modal">
        <div class="modal">
            <div class="modal-title">Enter Cell Number</div>
            <div class="modal-body">
                <div class="input-group mb-0">
                    <label for="cell-input">Cell Number (e.g., 195)</label>
                    <input type="text" id="cell-input" pattern="[0-9]{3}" maxlength="3" placeholder="000">
                    <span class="input-error" id="cell-input-error">Please enter a 3-digit cell number</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCellModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmCellNumber()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Pixel Selection Modal -->
    <div class="modal-overlay" id="pixel-modal">
        <div class="modal">
            <div class="modal-title">Select Pixel</div>
            <div class="modal-body">
                <div class="input-group mb-0">
                    <label for="pixel-input">Pixel Number (1-8)</label>
                    <input type="number" id="pixel-input" min="1" max="8" value="1">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closePixelModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmPixel()">Start</button>
            </div>
        </div>
    </div>

    <!-- Save Data Modal -->
    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <div class="modal-title">Save Data</div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: var(--text-secondary);">Which data would you like to save?</p>
                <div class="save-options">
                    <button class="btn btn-primary btn-block" id="save-power-btn" onclick="LabModals.confirmSavePower()" style="margin-bottom: 8px;">
                        Save Power Data
                    </button>
                    <button class="btn btn-primary btn-block" id="save-current-btn" onclick="LabModals.confirmSaveCurrent()">
                        Save Current Data
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="LabModals.closeSave()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div class="modal-overlay" id="error-modal">
        <div class="modal">
            <div class="modal-title" id="error-modal-title">Error</div>
            <div class="modal-body">
                <p id="error-modal-message" style="color: var(--text-secondary); white-space: pre-wrap; text-align: left;"></p>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button class="btn btn-primary" onclick="LabModals.closeError()">OK</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * EQE Measurement Application - Redesigned Layout
         */

        // State
        const state = {
            devices: {
                picoscope: { connected: false, message: '' },
                monochromator: { connected: false, message: '' },
                power_meter: { connected: false, message: '' }
            },
            offlineMode: false,
            measurementState: 'idle',
            currentPixel: null,
            cellNumber: '',
            wavelength: 0,
            shutterOpen: false,
            filter: 0,

            powerData: { x: [], y: [] },
            currentData: { x: [], y: [] },
            phaseData: { x: [], y: [] },
            stats: null
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            LabTheme.init();
            await LabAPI.init();

            setTimeout(() => {
                initPlots();
            }, 50);

            setTimeout(() => {
                const anyDeviceSet = state.devices.picoscope.message ||
                                     state.devices.monochromator.message ||
                                     state.devices.power_meter.message;
                if (!anyDeviceSet) {
                    checkDeviceStatus();
                }
            }, 500);

            // Initialize shared modal handlers
            LabModals.init();

            // Cell modal will be triggered by Python after window.show()
            // This ensures focus works after PicoScope splash screen
        });

        // Called by Python after window is shown to ensure proper focus
        function showStartupCellModal() {
            LabModals.showCell((cellNumber) => {
                document.getElementById('cell-number').value = cellNumber;
                state.cellNumber = cellNumber;
            });
        }

        // ==================== Plots ====================

        function getPlotLayout(isDark, xLabel, yLabel) {
            const colors = {
                text: isDark ? '#eeeeee' : '#1a1a1a',
                grid: isDark ? '#444444' : '#dddddd',
                zeroline: isDark ? '#666666' : '#999999',
                legendBg: isDark ? 'rgba(50,50,50,0.9)' : 'rgba(255,255,255,0.9)'
            };
            return {
                xaxis: {
                    title: xLabel,
                    color: colors.text,
                    gridcolor: colors.grid,
                    zerolinecolor: colors.zeroline,
                    zerolinewidth: 1
                },
                yaxis: {
                    title: yLabel,
                    color: colors.text,
                    gridcolor: colors.grid,
                    zerolinecolor: colors.zeroline,
                    zerolinewidth: 1
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: colors.text },
                legend: { font: { color: colors.text }, bgcolor: colors.legendBg },
                margin: { t: 20, r: 30, b: 60, l: 60 }
            };
        }

        const plotConfig = {
            displayModeBar: true,
            modeBarButtonsToRemove: ['lasso2d', 'select2d'],
            displaylogo: false
        };

        function initPlots() {
            const isDark = LabTheme.isDark();

            Plotly.newPlot('power-plot',
                [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Power',
                   marker: { color: '#4A90D9', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Power (µW)'),
                plotConfig
            );

            Plotly.newPlot('current-plot',
                [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Current',
                   marker: { color: '#66bb6a', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Current (nA)'),
                plotConfig
            );

            Plotly.newPlot('phase-plot',
                [
                    { x: [], y: [], mode: 'markers', type: 'scatter', name: 'Measured',
                      marker: { color: '#ff9800', size: 8 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Sine Fit',
                      line: { color: '#e57373', width: 2 } }
                ],
                getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                plotConfig
            );
        }

        window.addEventListener('resize', () => {
            if (typeof Plotly !== 'undefined') {
                Plotly.Plots.resize('power-plot');
                Plotly.Plots.resize('current-plot');
                Plotly.Plots.resize('phase-plot');
            }
        });

        window.addEventListener('themechange', (e) => {
            const isDark = e.detail.dark;
            ['power-plot', 'current-plot', 'phase-plot'].forEach(id => {
                const plotDiv = document.getElementById(id);
                if (plotDiv && plotDiv.data) {
                    const colors = {
                        text: isDark ? '#eeeeee' : '#1a1a1a',
                        grid: isDark ? '#444444' : '#dddddd',
                        zeroline: isDark ? '#666666' : '#999999'
                    };
                    Plotly.relayout(plotDiv, {
                        'xaxis.color': colors.text, 'xaxis.gridcolor': colors.grid,
                        'yaxis.color': colors.text, 'yaxis.gridcolor': colors.grid,
                        'font.color': colors.text
                    });
                }
            });
        });

        // ==================== Device Status ====================

        async function checkDeviceStatus() {
            try {
                const api = LabAPI.get();
                if (api && api.get_device_status) {
                    api.get_device_status((result) => {
                        const status = JSON.parse(result);
                        state.offlineMode = status.offline_mode;
                        updateDeviceIndicator('picoscope', status.picoscope);
                        updateDeviceIndicator('mono', status.monochromator);
                        updateDeviceIndicator('power', status.power_meter);
                        state.devices.picoscope = status.picoscope;
                        state.devices.monochromator = status.monochromator;
                        state.devices.power_meter = status.power_meter;
                        updateButtonStates();
                    });
                }
            } catch (error) {
                console.error('Device status check failed:', error);
            }
        }

        function updateDeviceIndicator(name, status) {
            const dot = document.getElementById(name + '-dot');
            const text = document.getElementById(name + '-status');

            // Check if offline mode from state or message
            const isOffline = state.offlineMode || (status.message && status.message.toUpperCase().includes('OFFLINE'));

            if (isOffline) {
                dot.className = 'device-dot warning';
            } else if (status.connected) {
                dot.className = 'device-dot connected';
            } else {
                dot.className = 'device-dot disconnected';
            }
            text.textContent = status.message || (status.connected ? 'Connected' : 'Not connected');
        }

        function updateButtonStates() {
            const canMeasure = state.offlineMode ||
                (state.devices.picoscope.connected && state.devices.monochromator.connected);
            const canPower = state.offlineMode ||
                (state.devices.power_meter.connected && state.devices.monochromator.connected);

            document.getElementById('power-btn').disabled = !canPower;
            document.getElementById('current-btn').disabled = !canMeasure;
            document.getElementById('live-btn').disabled = !canMeasure;
        }

        function onDeviceStatusChanged(deviceName, connected, message) {
            const nameMap = { 'Thorlabs Power Meter': 'power', 'Monochromator': 'mono', 'PicoScope Lock-in': 'picoscope' };
            const stateKeyMap = { 'Thorlabs Power Meter': 'power_meter', 'Monochromator': 'monochromator', 'PicoScope Lock-in': 'picoscope' };
            const id = nameMap[deviceName];
            const stateKey = stateKeyMap[deviceName];
            if (id && stateKey) {
                if (message && message.includes('OFFLINE')) state.offlineMode = true;
                updateDeviceIndicator(id, { connected, message });
                state.devices[stateKey] = { connected, message };
                updateButtonStates();
            }
        }

        // ==================== Monochromator ====================

        function updateMonochromatorDisplay() {
            document.getElementById('mono-wavelength').textContent = state.wavelength.toFixed(1);
            const badge = document.getElementById('shutter-badge');
            const btn = document.getElementById('shutter-btn');
            if (state.shutterOpen) {
                badge.className = 'shutter-badge open';
                badge.textContent = 'Open';
                btn.textContent = 'Close';
            } else {
                badge.className = 'shutter-badge closed';
                badge.textContent = 'Closed';
                btn.textContent = 'Open';
            }
        }

        function goToWavelength() {
            const wavelength = parseFloat(document.getElementById('wavelength-input').value);
            if (isNaN(wavelength) || wavelength < 200 || wavelength > 1200) {
                LabModals.showError('Invalid Wavelength', 'Enter wavelength between 200-1200 nm');
                return;
            }
            if (state.offlineMode) {
                state.wavelength = wavelength;
                updateMonochromatorDisplay();
                return;
            }
            const api = LabAPI.get();
            if (api && api.set_wavelength) {
                api.set_wavelength(wavelength, (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) LabModals.showError('Error', r.message);
                });
            }
        }

        function toggleShutter() {
            if (state.offlineMode) {
                state.shutterOpen = !state.shutterOpen;
                updateMonochromatorDisplay();
                return;
            }
            const api = LabAPI.get();
            if (state.shutterOpen) {
                if (api && api.close_shutter) api.close_shutter(() => {});
            } else {
                if (api && api.open_shutter) api.open_shutter(() => {});
            }
        }

        function alignMonochromator() {
            if (state.offlineMode) {
                state.wavelength = 532;
                state.shutterOpen = true;
                updateMonochromatorDisplay();
                return;
            }
            const api = LabAPI.get();
            if (api && api.align_monochromator) {
                api.align_monochromator((result) => {
                    const r = JSON.parse(result);
                    if (!r.success) LabModals.showError('Error', r.message);
                });
            }
        }

        function onMonochromatorStateChanged(wavelength, shutterOpen, filterNumber) {
            state.wavelength = wavelength;
            state.shutterOpen = shutterOpen;
            state.filter = filterNumber;
            updateMonochromatorDisplay();

            // Update live monitor status if active
            if (liveMonitorActive) {
                document.getElementById('progress-status').textContent =
                    'Live monitoring at ' + wavelength.toFixed(0) + ' nm';
            }
        }

        // ==================== Measurements ====================

        function getParams() {
            return {
                start_wavelength: parseFloat(document.getElementById('start-wavelength').value),
                end_wavelength: parseFloat(document.getElementById('end-wavelength').value),
                step_size: parseFloat(document.getElementById('step-size').value),
                cell_number: document.getElementById('cell-number').value || '000'
            };
        }

        function startPowerMeasurement() {
            const cell = document.getElementById('cell-number').value;
            if (!cell || !/^\d{3}$/.test(cell)) {
                LabModals.showCell((cellNumber) => {
                    document.getElementById('cell-number').value = cellNumber;
                    state.cellNumber = cellNumber;
                    startPowerMeasurement(); // Retry after cell number entered
                });
                return;
            }

            state.measurementState = 'power';
            state.powerData = { x: [], y: [] };
            clearPlot('power');
            setMeasuringState(true);
            updateProgress(0, 'Starting power measurement...');

            if (state.offlineMode) {
                mockPowerMeasurement();
                return;
            }

            const api = LabAPI.get();
            if (api && api.start_power_measurement) {
                api.start_power_measurement(JSON.stringify(getParams()), (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) {
                        LabModals.showError('Measurement Failed', r.message);
                        setMeasuringState(false);
                    }
                });
            }
        }

        function startCurrentMeasurement() {
            const cell = document.getElementById('cell-number').value;
            if (!cell || !/^\d{3}$/.test(cell)) {
                LabModals.showCell((cellNumber) => {
                    document.getElementById('cell-number').value = cellNumber;
                    state.cellNumber = cellNumber;
                    LabModals.showPixel(startCurrentMeasurementWithPixel);
                });
                return;
            }
            LabModals.showPixel(startCurrentMeasurementWithPixel);
        }

        function startCurrentMeasurementWithPixel(pixel) {
            state.currentPixel = pixel;
            state.measurementState = 'phase';
            state.phaseData = { x: [], y: [] };
            state.currentData = { x: [], y: [] };
            clearPlot('phase');
            clearPlot('current');
            setMeasuringState(true);
            updateProgress(0, 'Phase adjustment...');
            document.getElementById('pixel-label').textContent = 'Pixel: ' + pixel;
            document.getElementById('stats-row').classList.remove('hidden');

            if (state.offlineMode) {
                mockPhaseThenCurrentMeasurement(pixel);
                return;
            }

            const params = { ...getParams(), pixel };
            const api = LabAPI.get();
            if (api && api.start_current_measurement) {
                api.start_current_measurement(JSON.stringify(params), (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) {
                        LabModals.showError('Measurement Failed', r.message);
                        setMeasuringState(false);
                    }
                });
            }
        }

        function stopMeasurement() {
            if (state.offlineMode) {
                state.measurementState = 'idle';
                setMeasuringState(false);
                return;
            }
            const api = LabAPI.get();
            if (api && api.stop_measurement) api.stop_measurement(() => {});
            state.measurementState = 'idle';
            setMeasuringState(false);
        }

        function setMeasuringState(measuring) {
            document.getElementById('power-btn').disabled = measuring;
            document.getElementById('current-btn').disabled = measuring;
            document.getElementById('stop-btn').disabled = !measuring;
            document.getElementById('live-btn').disabled = measuring;

            // Disable save button when starting a new measurement
            if (measuring) {
                document.getElementById('save-btn').disabled = true;
            }

            // Disable parameter inputs
            const inputs = document.querySelectorAll('.params-grid input, .mono-controls-inline input');
            inputs.forEach(input => input.disabled = measuring);

            // Disable monochromator control buttons
            const monoButtons = document.querySelectorAll('.mono-controls-inline .btn');
            monoButtons.forEach(btn => btn.disabled = measuring);

            if (!measuring) {
                updateButtonStates();
                document.getElementById('stats-row').classList.add('hidden');
            }
        }

        function updateProgress(percent, status) {
            document.getElementById('progress-fill').style.width = percent + '%';
            document.getElementById('progress-percent').textContent = Math.round(percent) + '%';
            document.getElementById('progress-status').textContent = status;
        }

        // ==================== Plot Updates ====================

        function onPowerProgress(wavelength, power, percent) {
            const powerUW = power * 1e6;
            state.powerData.x.push(wavelength);
            state.powerData.y.push(powerUW);

            const isDark = LabTheme.isDark();
            Plotly.newPlot('power-plot',
                [{ x: state.powerData.x, y: state.powerData.y, mode: 'markers', type: 'scatter',
                   name: 'Power', marker: { color: '#4A90D9', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Power (µW)'),
                plotConfig
            );
            updateProgress(percent, `Measuring at ${wavelength.toFixed(0)} nm`);
        }

        function onCurrentProgress(wavelength, current, percent) {
            const currentNA = current * 1e9;
            state.currentData.x.push(wavelength);
            state.currentData.y.push(currentNA);

            if (state.measurementState === 'phase') {
                state.measurementState = 'current';
            }

            const isDark = LabTheme.isDark();
            Plotly.newPlot('current-plot',
                [{ x: state.currentData.x, y: state.currentData.y, mode: 'markers', type: 'scatter',
                   name: 'Current', marker: { color: '#66bb6a', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Current (nA)'),
                plotConfig
            );
            updateProgress(percent, `Measuring at ${wavelength.toFixed(0)} nm`);
        }

        function onPhaseProgress(phase, signal) {
            state.phaseData.x.push(phase);
            state.phaseData.y.push(signal);

            const isDark = LabTheme.isDark();
            Plotly.newPlot('phase-plot',
                [
                    { x: state.phaseData.x, y: state.phaseData.y, mode: 'markers', type: 'scatter',
                      name: 'Measured', marker: { color: '#ff9800', size: 8 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Sine Fit',
                      line: { color: '#e57373', width: 2 } }
                ],
                getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                plotConfig
            );
            updateProgress(0, `Phase adjustment: ${phase.toFixed(0)}°`);
        }

        function onMeasurementComplete(success, message) {
            state.measurementState = 'idle';
            setMeasuringState(false);

            if (success) {
                updateProgress(100, 'Complete');
                // Enable save button and auto-save
                document.getElementById('save-btn').disabled = false;
                if (state.powerData.x.length > 0) savePowerData();
                else if (state.currentData.x.length > 0) saveCurrentData();
            } else {
                // Show error message to user
                updateProgress(0, 'Failed');
                if (message && message !== 'Stopped') {
                    LabModals.showError('Measurement Failed', message);
                }
            }
        }

        function onMeasurementStats(stats) {
            state.stats = stats;
            document.getElementById('stats-n').textContent = `${stats.n}/${stats.total}`;
            document.getElementById('stats-outliers').textContent = stats.outliers;
            document.getElementById('stats-cv').textContent = stats.cv_percent.toFixed(1) + '%';
            const badge = document.getElementById('stats-quality');
            badge.textContent = stats.quality;
            badge.className = 'quality-badge quality-' + stats.quality.toLowerCase();
        }

        function clearPlot(type) {
            const isDark = LabTheme.isDark();
            if (type === 'power') {
                Plotly.newPlot('power-plot',
                    [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Power',
                       marker: { color: '#4A90D9', size: 8 } }],
                    getPlotLayout(isDark, 'Wavelength (nm)', 'Power (µW)'),
                    plotConfig
                );
            } else if (type === 'current') {
                Plotly.newPlot('current-plot',
                    [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Current',
                       marker: { color: '#66bb6a', size: 8 } }],
                    getPlotLayout(isDark, 'Wavelength (nm)', 'Current (nA)'),
                    plotConfig
                );
            } else if (type === 'phase') {
                Plotly.newPlot('phase-plot',
                    [
                        { x: [], y: [], mode: 'markers', type: 'scatter', name: 'Measured',
                          marker: { color: '#ff9800', size: 8 } },
                        { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Sine Fit',
                          line: { color: '#e57373', width: 2 } }
                    ],
                    getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                    plotConfig
                );
            }
        }

        // ==================== Live Monitor ====================

        let liveMonitorActive = false;

        function toggleLiveMonitor() {
            if (liveMonitorActive) {
                stopLiveMonitor();
            } else {
                startLiveMonitor();
            }
        }

        function startLiveMonitor() {
            liveMonitorActive = true;
            state.measurementState = 'live_monitor';
            document.getElementById('live-btn').textContent = 'Stop Monitor';
            document.getElementById('live-btn').className = 'btn btn-danger';
            document.getElementById('progress-bar-row').classList.add('hidden');
            document.getElementById('live-reading').classList.remove('hidden');
            document.getElementById('power-btn').disabled = true;
            document.getElementById('current-btn').disabled = true;
            document.getElementById('progress-status').textContent = 'Starting live monitor...';

            if (state.offlineMode) {
                mockLiveMonitor();
                return;
            }

            const api = LabAPI.get();
            if (api && api.start_live_monitor) api.start_live_monitor(() => {});
        }

        function stopLiveMonitor() {
            liveMonitorActive = false;
            state.measurementState = 'idle';
            document.getElementById('live-btn').textContent = 'Live Monitor';
            document.getElementById('live-btn').className = 'btn btn-secondary';
            document.getElementById('progress-bar-row').classList.remove('hidden');
            document.getElementById('live-reading').classList.add('hidden');
            updateButtonStates();
            updateProgress(0, 'Ready');

            if (!state.offlineMode) {
                const api = LabAPI.get();
                if (api && api.stop_live_monitor) api.stop_live_monitor(() => {});
            }
        }

        function onLiveSignalUpdate(currentNA) {
            document.getElementById('live-value').textContent = currentNA.toFixed(2);
        }

        // ==================== Data Export ====================

        function saveData() {
            const hasPower = state.powerData.x.length > 0;
            const hasCurrent = state.currentData.x.length > 0;

            if (!hasPower && !hasCurrent) {
                LabModals.showError('No Data', 'No measurement data to save');
                return;
            }

            // Show the save modal with callback
            LabModals.showSave({ hasPower, hasCurrent }, (type) => {
                if (type === 'power') {
                    savePowerData();
                } else if (type === 'current') {
                    saveCurrentData();
                }
            });
        }

        function savePowerData() {
            let csv = 'Wavelength (nm),Power (uW)\n';
            for (let i = 0; i < state.powerData.x.length; i++) {
                csv += `${state.powerData.x[i].toFixed(1)},${state.powerData.y[i].toFixed(6)}\n`;
            }
            const api = LabAPI.get();
            if (api && api.save_power_data) {
                api.save_power_data(csv, document.getElementById('cell-number').value, (result) => {
                    const r = JSON.parse(result);
                    if (r.success) console.log('Saved:', r.path);
                    else if (r.message !== 'Cancelled') LabModals.showError('Save Failed', r.message);
                });
            }
        }

        function saveCurrentData() {
            let csv = 'Wavelength (nm),Current (nA)\n';
            for (let i = 0; i < state.currentData.x.length; i++) {
                csv += `${state.currentData.x[i].toFixed(1)},${state.currentData.y[i].toFixed(6)}\n`;
            }
            const api = LabAPI.get();
            if (api && api.save_current_data) {
                api.save_current_data(csv, document.getElementById('cell-number').value, state.currentPixel, (result) => {
                    const r = JSON.parse(result);
                    if (r.success) console.log('Saved:', r.path);
                    else if (r.message !== 'Cancelled') LabModals.showError('Save Failed', r.message);
                });
            }
        }

        // ==================== Mock Measurements ====================

        function mockPowerMeasurement() {
            const params = getParams();
            let wavelength = params.start_wavelength;
            const end = params.end_wavelength;
            const step = params.step_size;
            const total = Math.ceil((end - wavelength) / step) + 1;
            let count = 0;

            // Open shutter at start
            state.shutterOpen = true;
            updateMonochromatorDisplay();

            const interval = setInterval(() => {
                if (state.measurementState !== 'power' || wavelength > end) {
                    clearInterval(interval);
                    if (state.measurementState === 'power') {
                        state.shutterOpen = false;
                        updateMonochromatorDisplay();
                        onMeasurementComplete(true, 'Complete');
                    }
                    return;
                }
                const power = 2e-6 * Math.exp(-Math.pow((wavelength - 550) / 100, 2)) * (0.9 + 0.2 * Math.random());
                count++;

                // Update monochromator display
                state.wavelength = wavelength;
                updateMonochromatorDisplay();

                onPowerProgress(wavelength, power, (count / total) * 100);
                wavelength += step;
            }, 100);
        }

        function mockPhaseThenCurrentMeasurement(pixel) {
            let phase = 0;

            // Set to 532nm for phase adjustment, open shutter
            state.wavelength = 532;
            state.shutterOpen = true;
            updateMonochromatorDisplay();

            const phaseInterval = setInterval(() => {
                if (state.measurementState === 'idle' || phase > 360) {
                    clearInterval(phaseInterval);
                    if (state.measurementState !== 'idle') {
                        state.measurementState = 'current';
                        mockCurrentMeasurement();
                    }
                    return;
                }
                const signal = 0.5 + 0.4 * Math.sin((phase - 45) * Math.PI / 180) + 0.02 * Math.random();
                onPhaseProgress(phase, signal);
                phase += 15;
            }, 50);
        }

        function mockCurrentMeasurement() {
            const params = getParams();
            let wavelength = params.start_wavelength;
            const end = params.end_wavelength;
            const step = params.step_size;
            const total = Math.ceil((end - wavelength) / step) + 1;
            let count = 0;

            const interval = setInterval(() => {
                if (state.measurementState !== 'current' || wavelength > end) {
                    clearInterval(interval);
                    if (state.measurementState === 'current') {
                        state.shutterOpen = false;
                        updateMonochromatorDisplay();
                        onMeasurementComplete(true, 'Complete');
                    }
                    return;
                }
                const bandgap = 750;
                let current;
                if (wavelength < bandgap) {
                    current = 2e-9 * (1 - Math.exp(-(wavelength - 350) / 50)) * (0.9 + 0.2 * Math.random());
                } else {
                    current = 2e-9 * Math.exp(-(wavelength - bandgap) / 30) * (0.9 + 0.2 * Math.random());
                }
                count++;

                // Update monochromator display
                state.wavelength = wavelength;
                updateMonochromatorDisplay();

                onMeasurementStats({
                    mean: current * 1e9,
                    std_dev: current * 1e9 * 0.02,
                    n: 5, total: 5, outliers: 0,
                    cv_percent: 2.0, quality: 'Excellent'
                });

                onCurrentProgress(wavelength, current, (count / total) * 100);
                wavelength += step;
            }, 150);
        }

        function mockLiveMonitor() {
            // Set to 532nm for live monitor, open shutter
            state.wavelength = 532;
            state.shutterOpen = true;
            updateMonochromatorDisplay();
            document.getElementById('progress-status').textContent = 'Live monitoring at 532 nm';

            const mockInterval = setInterval(() => {
                if (!liveMonitorActive) {
                    clearInterval(mockInterval);
                    state.shutterOpen = false;
                    updateMonochromatorDisplay();
                    return;
                }
                onLiveSignalUpdate(1.5 + 0.5 * Math.random());
            }, 500);
        }

        // Global callbacks for Python
        window.onDeviceStatusChanged = onDeviceStatusChanged;
        window.onMonochromatorStateChanged = onMonochromatorStateChanged;
        window.onPowerProgress = onPowerProgress;
        window.onCurrentProgress = onCurrentProgress;
        window.onPhaseProgress = onPhaseProgress;
        window.onMeasurementComplete = onMeasurementComplete;
        window.onMeasurementStats = onMeasurementStats;
        window.onLiveSignalUpdate = onLiveSignalUpdate;
    </script>
</body>
</html>
