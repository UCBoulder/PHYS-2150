<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EQE Measurement - PHYS 2150</title>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="css/theme.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/eqe-layout.css">

    <!-- Plotly.js for interactive plots (local copy) -->
    <script src="js/plotly.min.js"></script>

    <!-- Qt WebChannel -->
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <!-- Shared modules -->
    <script src="js/api.js"></script>
    <script src="js/theme.js"></script>
    <script src="js/modals.js"></script>
</head>
<body class="dark-mode eqe-body">
    <div class="eqe-app">
        <!-- Tab Navigation with Header Actions -->
        <div class="tab-bar">
            <button class="tab-btn active" onclick="switchTab('measurement')">Measurement</button>
            <button class="tab-btn" onclick="switchTab('stability')">Stability Test</button>
            <button class="tab-btn staff-tab" id="analysis-tab-btn" onclick="switchTab('analysis')" style="display: none;">
                EQE Analysis
                <span class="staff-badge-small">STAFF</span>
            </button>
            <div class="tab-bar-spacer"></div>
            <span id="pixel-label" class="text-muted">Pixel: --</span>
            <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                <svg id="sun-icon" class="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"/>
                    <line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                    <line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                </svg>
                <svg id="moon-icon" class="theme-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                </svg>
            </button>
        </div>

        <!-- Hidden file inputs for EQE Analysis -->
        <input type="file" id="power-file-input" accept=".csv" style="display: none;" onchange="onPowerFileSelected(event)">
        <input type="file" id="current-file-input" accept=".csv" style="display: none;" onchange="onCurrentFileSelected(event)">

        <!-- Device Status Row with Monochromator Controls (shared across tabs) -->
        <div class="device-status-row">
            <span class="row-section-title">Device Status</span>
            <div class="device-item">
                <span class="device-dot disconnected" id="picoscope-dot"></span>
                <span class="device-name">PicoScope:</span>
                <span class="device-status" id="picoscope-status">Connecting...</span>
            </div>
            <div class="device-item">
                <span class="device-dot disconnected" id="mono-dot"></span>
                <span class="device-name">Monochromator:</span>
                <span class="device-status" id="mono-status">Connecting...</span>
            </div>
            <div class="device-item">
                <span class="device-dot disconnected" id="power-dot"></span>
                <span class="device-name">Power Meter:</span>
                <span class="device-status" id="power-status">Connecting...</span>
            </div>

            <div class="mono-controls-inline">
                <span class="row-section-title">Monochromator</span>
                <span class="mono-state"><span id="mono-wavelength">--</span> nm</span>
                <span class="shutter-badge closed" id="shutter-badge">Closed</span>
                <input type="number" id="wavelength-input" placeholder="nm" min="200" max="1200">
                <button class="btn btn-secondary btn-small" onclick="goToWavelength()">Go</button>
                <button class="btn btn-secondary btn-small" id="shutter-btn" onclick="toggleShutter()">Open</button>
                <button class="btn btn-secondary btn-small" onclick="alignMonochromator()">Align</button>
            </div>
        </div>

        <!-- ==================== MEASUREMENT TAB ==================== -->
        <div id="tab-measurement" class="tab-content active">

        <!-- Top Section: Parameters + Progress -->
        <div class="top-section">
            <div class="params-panel">
                <div class="panel-title">Measurement Parameters</div>
                <div class="params-grid">
                    <div class="param-field">
                        <label>Start (nm)</label>
                        <input type="number" id="start-wavelength" value="350" step="10">
                    </div>
                    <div class="param-field">
                        <label>End (nm)</label>
                        <input type="number" id="end-wavelength" value="750" step="10">
                    </div>
                    <div class="param-field">
                        <label>Step (nm)</label>
                        <input type="number" id="step-size" value="10" step="1">
                    </div>
                    <div class="param-field">
                        <label>Cell Number</label>
                        <input type="text" id="cell-number" placeholder="e.g. 140" maxlength="3">
                    </div>
                </div>
            </div>

            <div class="progress-panel">
                <div class="panel-title">Status</div>
                <div class="progress-content">
                    <div class="progress-status" id="progress-status">Ready</div>
                    <div class="progress-bar-container" id="progress-bar-row">
                        <div class="progress-bar">
                            <div class="progress-bar-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="progress-percent" id="progress-percent">0%</span>
                    </div>
                    <div class="live-reading hidden" id="live-reading">
                        <span id="live-value">--</span> nA
                    </div>
                </div>
            </div>
        </div>

        <!-- Three Plots Row -->
        <div class="plots-row">
            <div class="plot-panel">
                <div class="plot-title">Incident Light Power</div>
                <div class="plot-container">
                    <div id="power-plot" class="plot"></div>
                </div>
            </div>

            <div class="plot-panel">
                <div class="plot-title">PV Current</div>
                <div class="plot-container">
                    <div id="current-plot" class="plot"></div>
                </div>
                <div class="stats-row hidden" id="stats-row">
                    <span class="stat-item">n: <span class="stat-value" id="stats-n">--</span></span>
                    <span class="stat-item">CV: <span class="stat-value" id="stats-cv">--%</span></span>
                    <span class="quality-badge" id="stats-quality">--</span>
                </div>
            </div>

            <div class="plot-panel">
                <div class="plot-title">Phase Response and Sine Fit</div>
                <div class="plot-container">
                    <div id="phase-plot" class="plot"></div>
                </div>
            </div>
        </div>

        <!-- Buttons Row -->
        <div class="buttons-row">
            <button class="btn btn-primary" id="power-btn" onclick="startPowerMeasurement()">
                Start Power Measurement
            </button>
            <button class="btn btn-primary" id="current-btn" onclick="startCurrentMeasurement()">
                Start Current Measurement
            </button>
            <button class="btn btn-danger" id="stop-btn" onclick="stopMeasurement()" disabled>
                Stop
            </button>
            <button class="btn btn-secondary" id="save-btn" onclick="saveData()" disabled>
                Save Data
            </button>
            <button class="btn btn-secondary" id="live-btn" onclick="toggleLiveMonitor()">
                Live Monitor
            </button>
        </div>

        </div><!-- End Measurement Tab -->

        <!-- ==================== STABILITY TEST TAB ==================== -->
        <div id="tab-stability" class="tab-content">

        <!-- Configuration Row -->
        <div class="stability-config">
            <div class="stability-config-panel">
                <div class="config-header">
                    <div class="panel-title">Test Configuration</div>
                    <div class="test-type-selector">
                        <label>Test Type:</label>
                        <div class="radio-group">
                            <label class="radio-option">
                                <input type="radio" name="stability-type" value="power" checked onchange="onStabilityTypeChange()">
                                <span>Power</span>
                            </label>
                            <label class="radio-option">
                                <input type="radio" name="stability-type" value="current" onchange="onStabilityTypeChange()">
                                <span>Current</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="params-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <div class="param-field">
                        <label>Wavelength (nm)</label>
                        <input type="number" id="stability-wavelength" value="550" step="10">
                    </div>
                    <div class="param-field">
                        <label>Duration (min)</label>
                        <input type="number" id="stability-duration" value="5" min="1" max="60">
                    </div>
                    <div class="param-field">
                        <label>Interval (sec)</label>
                        <input type="number" id="stability-interval" value="2" min="1" max="60">
                    </div>
                </div>
            </div>

            <div class="progress-panel">
                <div class="panel-title">Status</div>
                <div class="progress-content">
                    <div class="progress-status" id="stability-status">Ready</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar">
                            <div class="progress-bar-fill" id="stability-progress-fill" style="width: 0%"></div>
                        </div>
                        <span class="progress-percent" id="stability-progress-percent">0%</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Dual Plots Row -->
        <div class="stability-plots">
            <div class="plot-panel">
                <div class="plot-title">Time Series</div>
                <div class="plot-container">
                    <div id="stability-time-plot" class="plot"></div>
                </div>
            </div>
            <div class="plot-panel">
                <div class="plot-title">Histogram</div>
                <div class="plot-container">
                    <div id="stability-hist-plot" class="plot"></div>
                </div>
            </div>
        </div>

        <!-- Statistics Bar -->
        <div class="stability-stats-bar">
            <div class="stability-stat">
                <span class="stability-stat-label">Mean:</span>
                <span class="stability-stat-value" id="stability-mean">--</span>
            </div>
            <div class="stability-stat">
                <span class="stability-stat-label">Std Dev:</span>
                <span class="stability-stat-value" id="stability-std">--</span>
            </div>
            <div class="stability-stat">
                <span class="stability-stat-label">CV:</span>
                <span class="stability-stat-value cv" id="stability-cv">--%</span>
            </div>
            <div class="stability-stat">
                <span class="stability-stat-label">Count:</span>
                <span class="stability-stat-value" id="stability-count">0</span>
            </div>
            <div class="stability-stat">
                <span class="stability-stat-label">Range:</span>
                <span class="stability-stat-value" id="stability-range">--</span>
            </div>
        </div>

        <!-- Buttons Row -->
        <div class="buttons-row">
            <button class="btn btn-primary" id="stability-start-btn" onclick="startStabilityTest()">
                Start Test
            </button>
            <button class="btn btn-danger" id="stability-stop-btn" onclick="stopStabilityTest()" disabled>
                Stop Test
            </button>
            <button class="btn btn-secondary" id="stability-save-btn" onclick="saveStabilityData()" disabled>
                Save Results
            </button>
        </div>

        </div><!-- End Stability Tab -->

        <!-- EQE Analysis Tab (Staff Mode - Ctrl+Shift+E) -->
        <div id="tab-analysis" class="tab-content">
            <!-- Top Section: Data Source + Status -->
            <div class="top-section">
                <div class="params-panel analysis-source-panel">
                    <div class="panel-title">Data Source</div>
                    <div class="analysis-source-layout">
                        <div class="analysis-data-grid">
                            <span class="analysis-data-label">Power:</span>
                            <button class="btn btn-secondary btn-xs" id="use-power-session-btn" onclick="usePowerSession()" disabled>Session</button>
                            <button class="btn btn-secondary btn-xs" onclick="loadPowerCSV()">Load File</button>
                            <span class="analysis-file-status" id="power-file-status">No data</span>

                            <span class="analysis-data-label">Current:</span>
                            <button class="btn btn-secondary btn-xs" id="use-current-session-btn" onclick="useCurrentSession()" disabled>Session</button>
                            <button class="btn btn-secondary btn-xs" onclick="loadCurrentCSV()">Load File</button>
                            <span class="analysis-file-status" id="current-file-status">No data</span>
                        </div>
                        <button class="btn btn-primary" id="calculate-eqe-btn" onclick="calculateEQE()" disabled>
                            Calculate EQE
                        </button>
                    </div>
                </div>

                <div class="progress-panel">
                    <div class="panel-title">Status</div>
                    <div class="progress-content">
                        <div class="progress-status analysis-status-text" id="analysis-status">Ready - load power and current data to calculate EQE</div>
                    </div>
                </div>
            </div>

            <!-- Plot Row: EQE Spectrum + Results -->
            <div class="analysis-plots-row">
                <div class="plot-panel analysis-eqe-panel">
                    <div class="plot-title">EQE Spectrum</div>
                    <div class="plot-container">
                        <div id="eqe-plot" class="plot"></div>
                    </div>
                </div>

                <div class="params-panel analysis-results-panel">
                    <div class="panel-title">Results</div>
                    <div class="analysis-metrics">
                        <div class="analysis-metric">
                            <span class="analysis-metric-label">Peak EQE</span>
                            <span class="analysis-metric-value peak" id="metric-peak-eqe">--%</span>
                            <span class="analysis-metric-detail" id="metric-peak-wavelength">at -- nm</span>
                        </div>
                        <div class="analysis-metric">
                            <span class="analysis-metric-label">Bandgap Edge</span>
                            <span class="analysis-metric-value" id="metric-bandgap">-- nm</span>
                            <span class="analysis-metric-detail" id="metric-bandgap-ev">(-- eV)</span>
                        </div>
                        <div class="analysis-metric">
                            <span class="analysis-metric-label">Data Points</span>
                            <span class="analysis-metric-value" id="metric-datapoints">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div><!-- End Analysis Tab -->

    </div>

    <!-- Cell Number Modal (shown on startup) -->
    <div class="modal-overlay" id="cell-modal">
        <div class="modal">
            <div class="modal-title">Enter Cell Number</div>
            <div class="modal-body">
                <div class="input-group mb-0">
                    <label for="cell-input">Cell Number (e.g., 195)</label>
                    <input type="text" id="cell-input" pattern="[0-9]{3}" maxlength="3" placeholder="000">
                    <span class="input-error" id="cell-input-error">Please enter a 3-digit cell number</span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCellModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmCellNumber()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Pixel Selection Modal -->
    <div class="modal-overlay" id="pixel-modal">
        <div class="modal">
            <div class="modal-title">Select Pixel</div>
            <div class="modal-body">
                <div class="input-group mb-0">
                    <label for="pixel-input">Pixel Number (1-8)</label>
                    <input type="number" id="pixel-input" min="1" max="8" value="1">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closePixelModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmPixel()">Start</button>
            </div>
        </div>
    </div>

    <!-- Save Data Modal -->
    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <div class="modal-title">Save Data</div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: var(--text-secondary);">Which data would you like to save?</p>
                <div class="save-options">
                    <button class="btn btn-primary btn-block" id="save-power-btn" onclick="LabModals.confirmSavePower()" style="margin-bottom: 8px;">
                        Save Power Data
                    </button>
                    <button class="btn btn-primary btn-block" id="save-current-btn" onclick="LabModals.confirmSaveCurrent()">
                        Save Current Data
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="LabModals.closeSave()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Error Modal -->
    <div class="modal-overlay" id="error-modal">
        <div class="modal">
            <div class="modal-title" id="error-modal-title">Error</div>
            <div class="modal-body">
                <p id="error-modal-message" style="color: var(--text-secondary); white-space: pre-wrap; text-align: left;"></p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="LabModals.closeError()">OK</button>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div class="modal-overlay" id="info-modal">
        <div class="modal">
            <div class="modal-title" id="info-modal-title">Info</div>
            <div class="modal-body">
                <p id="info-modal-message" style="color: var(--text-secondary); white-space: pre-line;"></p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="LabModals.closeInfo()">OK</button>
            </div>
        </div>
    </div>

    <script>
        /**
         * EQE Measurement Application - Redesigned Layout
         */

        // State
        const state = {
            activeTab: 'measurement',
            devices: {
                picoscope: { connected: false, message: '' },
                monochromator: { connected: false, message: '' },
                power_meter: { connected: false, message: '' }
            },
            offlineMode: false,
            measurementState: 'idle',
            currentPixel: null,
            cellNumber: '',
            wavelength: 0,
            shutterOpen: false,
            filter: 0,

            powerData: { x: [], y: [] },
            currentData: { x: [], y: [], stats: [] },  // stats array stores per-point statistics
            phaseData: { x: [], y: [] },
            stats: null,  // current measurement stats (for UI display)

            // Stability test state
            stability: {
                testType: 'power',  // 'power' | 'current'
                running: false,
                pixel: null,
                data: { times: [], values: [] },
                stats: null,  // {mean, std, cv_percent, min, max, range, count}
                startTime: null
            },

            // EQE Analysis state (staff mode)
            analysis: {
                visible: false,
                powerData: null,   // {wavelengths: [], values: []}
                currentData: null, // {wavelengths: [], values: []}
                eqeData: null,     // {wavelengths: [], eqe: []}
                metrics: null      // {peakEQE, peakWavelength, bandgapWavelength, bandgapEV, dataPoints}
            },

            // Debug mode
            debugMode: false
        };

        // ==================== Tab Navigation ====================

        function switchTab(tabName) {
            // Don't switch if a test is running
            if (state.measurementState !== 'idle' && state.measurementState !== 'live_monitor') {
                LabModals.showError('Cannot Switch', 'Please stop the current measurement before switching tabs.');
                return;
            }
            if (state.stability.running) {
                LabModals.showError('Cannot Switch', 'Please stop the stability test before switching tabs.');
                return;
            }

            state.activeTab = tabName;

            // Update tab buttons - use data attribute for reliable matching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                const btnTab = btn.getAttribute('onclick')?.match(/switchTab\('(\w+)'\)/)?.[1];
                btn.classList.toggle('active', btnTab === tabName);
            });

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === 'tab-' + tabName);
            });

            // Initialize plots for the new tab if needed
            if (tabName === 'stability') {
                setTimeout(() => initStabilityPlots(), 50);
            } else if (tabName === 'analysis') {
                setTimeout(() => {
                    const plotDiv = document.getElementById('eqe-plot');
                    // Only init if plot doesn't exist yet; otherwise just resize
                    if (!plotDiv.data) {
                        initEQEPlot();
                    } else {
                        Plotly.Plots.resize('eqe-plot');
                    }
                    updateSessionDataButton();
                }, 50);
            } else {
                setTimeout(() => {
                    Plotly.Plots.resize('power-plot');
                    Plotly.Plots.resize('current-plot');
                    Plotly.Plots.resize('phase-plot');
                }, 50);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            LabTheme.init();
            await LabAPI.init();

            setTimeout(() => {
                initPlots();
            }, 50);

            setTimeout(() => {
                const anyDeviceSet = state.devices.picoscope.message ||
                                     state.devices.monochromator.message ||
                                     state.devices.power_meter.message;
                if (!anyDeviceSet) {
                    checkDeviceStatus();
                }
            }, 500);

            // Initialize shared modal handlers
            LabModals.init();

            // Cell modal will be triggered by Python after window.show()
            // This ensures focus works after PicoScope splash screen
        });

        // Called by Python after window is shown to ensure proper focus
        function showStartupCellModal() {
            LabModals.showCell((cellNumber) => {
                document.getElementById('cell-number').value = cellNumber;
                state.cellNumber = cellNumber;
            });
        }

        // ==================== Plots ====================

        function getPlotLayout(isDark, xLabel, yLabel) {
            const colors = {
                text: isDark ? '#eeeeee' : '#1a1a1a',
                grid: isDark ? '#444444' : '#dddddd',
                zeroline: isDark ? '#666666' : '#999999',
                legendBg: isDark ? 'rgba(50,50,50,0.8)' : 'rgba(255,255,255,0.8)'
            };
            return {
                xaxis: {
                    title: xLabel,
                    color: colors.text,
                    gridcolor: colors.grid,
                    zerolinecolor: colors.zeroline,
                    zerolinewidth: 1
                },
                yaxis: {
                    title: yLabel,
                    color: colors.text,
                    gridcolor: colors.grid,
                    zerolinecolor: colors.zeroline,
                    zerolinewidth: 1
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: colors.text },
                legend: {
                    font: { color: colors.text, size: 11 },
                    bgcolor: colors.legendBg,
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    yanchor: 'top'
                },
                margin: { t: 20, r: 30, b: 95, l: 60 }
            };
        }

        const plotConfig = {
            displayModeBar: true,
            modeBarButtonsToRemove: ['lasso2d', 'select2d', 'toImage'],
            displaylogo: false
        };

        function initPlots() {
            const isDark = LabTheme.isDark();

            Plotly.newPlot('power-plot',
                [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Power',
                   marker: { color: '#4A90D9', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Power (µW)'),
                plotConfig
            );

            Plotly.newPlot('current-plot',
                [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Current',
                   marker: { color: '#66bb6a', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Current (nA)'),
                plotConfig
            );

            Plotly.newPlot('phase-plot',
                [
                    { x: [], y: [], mode: 'markers', type: 'scatter', name: 'Measured',
                      marker: { color: '#ff9800', size: 8 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Sine Fit',
                      line: { color: '#e57373', width: 2 } }
                ],
                getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                plotConfig
            );
        }

        window.addEventListener('resize', () => {
            if (typeof Plotly !== 'undefined') {
                Plotly.Plots.resize('power-plot');
                Plotly.Plots.resize('current-plot');
                Plotly.Plots.resize('phase-plot');
            }
        });

        window.addEventListener('themechange', (e) => {
            const isDark = e.detail.dark;
            // Update all plots: measurement, stability, and analysis
            const plotIds = [
                'power-plot', 'current-plot', 'phase-plot',  // Measurement
                'stability-time-plot', 'stability-hist-plot',  // Stability
                'eqe-plot'  // Analysis
            ];
            plotIds.forEach(id => {
                const plotDiv = document.getElementById(id);
                if (plotDiv && plotDiv.data) {
                    const colors = {
                        text: isDark ? '#eeeeee' : '#1a1a1a',
                        grid: isDark ? '#444444' : '#dddddd',
                        zeroline: isDark ? '#666666' : '#999999',
                        paper: isDark ? '#2a2a2a' : '#ffffff',
                        plot: isDark ? '#2a2a2a' : '#ffffff'
                    };
                    Plotly.relayout(plotDiv, {
                        'xaxis.color': colors.text, 'xaxis.gridcolor': colors.grid,
                        'yaxis.color': colors.text, 'yaxis.gridcolor': colors.grid,
                        'font.color': colors.text,
                        'paper_bgcolor': colors.paper,
                        'plot_bgcolor': colors.plot
                    });
                }
            });
        });

        // ==================== Device Status ====================

        async function checkDeviceStatus() {
            try {
                const api = LabAPI.get();
                if (api && api.get_device_status) {
                    api.get_device_status((result) => {
                        const status = JSON.parse(result);
                        state.offlineMode = status.offline_mode;
                        updateDeviceIndicator('picoscope', status.picoscope);
                        updateDeviceIndicator('mono', status.monochromator);
                        updateDeviceIndicator('power', status.power_meter);
                        state.devices.picoscope = status.picoscope;
                        state.devices.monochromator = status.monochromator;
                        state.devices.power_meter = status.power_meter;
                        updateButtonStates();
                    });
                }
            } catch (error) {
                console.error('Device status check failed:', error);
            }
        }

        function updateDeviceIndicator(name, status) {
            const dot = document.getElementById(name + '-dot');
            const text = document.getElementById(name + '-status');

            // Check if offline mode from state or message
            const isOffline = state.offlineMode || (status.message && status.message.toUpperCase().includes('OFFLINE'));

            if (isOffline) {
                dot.className = 'device-dot warning';
            } else if (status.connected) {
                dot.className = 'device-dot connected';
            } else {
                dot.className = 'device-dot disconnected';
            }
            text.textContent = status.message || (status.connected ? 'Connected' : 'Not connected');
        }

        function updateButtonStates() {
            const canMeasure = state.offlineMode ||
                (state.devices.picoscope.connected && state.devices.monochromator.connected);
            const canPower = state.offlineMode ||
                (state.devices.power_meter.connected && state.devices.monochromator.connected);

            document.getElementById('power-btn').disabled = !canPower;
            document.getElementById('current-btn').disabled = !canMeasure;
            document.getElementById('live-btn').disabled = !canMeasure;
        }

        function onDeviceStatusChanged(deviceName, connected, message) {
            const nameMap = { 'Thorlabs Power Meter': 'power', 'Monochromator': 'mono', 'PicoScope Lock-in': 'picoscope' };
            const stateKeyMap = { 'Thorlabs Power Meter': 'power_meter', 'Monochromator': 'monochromator', 'PicoScope Lock-in': 'picoscope' };
            const id = nameMap[deviceName];
            const stateKey = stateKeyMap[deviceName];
            if (id && stateKey) {
                if (message && message.includes('OFFLINE')) state.offlineMode = true;
                updateDeviceIndicator(id, { connected, message });
                state.devices[stateKey] = { connected, message };
                updateButtonStates();
            }
        }

        // ==================== Monochromator ====================

        function updateMonochromatorDisplay() {
            document.getElementById('mono-wavelength').textContent = state.wavelength.toFixed(1);
            const badge = document.getElementById('shutter-badge');
            const btn = document.getElementById('shutter-btn');
            if (state.shutterOpen) {
                badge.className = 'shutter-badge open';
                badge.textContent = 'Open';
                btn.textContent = 'Close';
            } else {
                badge.className = 'shutter-badge closed';
                badge.textContent = 'Closed';
                btn.textContent = 'Open';
            }
        }

        function goToWavelength() {
            const wavelength = parseFloat(document.getElementById('wavelength-input').value);
            if (isNaN(wavelength) || wavelength < 200 || wavelength > 1200) {
                LabModals.showError('Invalid Wavelength', 'Enter wavelength between 200-1200 nm');
                return;
            }
            if (state.offlineMode) {
                state.wavelength = wavelength;
                updateMonochromatorDisplay();
                return;
            }
            const api = LabAPI.get();
            if (api && api.set_wavelength) {
                api.set_wavelength(wavelength, (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) LabModals.showError('Error', r.message);
                });
            }
        }

        function toggleShutter() {
            if (state.offlineMode) {
                state.shutterOpen = !state.shutterOpen;
                updateMonochromatorDisplay();
                return;
            }
            const api = LabAPI.get();
            if (state.shutterOpen) {
                if (api && api.close_shutter) api.close_shutter(() => {});
            } else {
                if (api && api.open_shutter) api.open_shutter(() => {});
            }
        }

        function alignMonochromator() {
            if (state.offlineMode) {
                state.wavelength = 532;
                state.shutterOpen = true;
                updateMonochromatorDisplay();
                return;
            }
            const api = LabAPI.get();
            if (api && api.align_monochromator) {
                api.align_monochromator((result) => {
                    const r = JSON.parse(result);
                    if (!r.success) LabModals.showError('Error', r.message);
                });
            }
        }

        function onMonochromatorStateChanged(wavelength, shutterOpen, filterNumber) {
            state.wavelength = wavelength;
            state.shutterOpen = shutterOpen;
            state.filter = filterNumber;
            updateMonochromatorDisplay();

            // Update live monitor status if active
            if (liveMonitorActive) {
                document.getElementById('progress-status').textContent =
                    'Live monitoring at ' + wavelength.toFixed(0) + ' nm';
            }
        }

        // ==================== Measurements ====================

        function getParams() {
            return {
                start_wavelength: parseFloat(document.getElementById('start-wavelength').value),
                end_wavelength: parseFloat(document.getElementById('end-wavelength').value),
                step_size: parseFloat(document.getElementById('step-size').value),
                cell_number: document.getElementById('cell-number').value || '000'
            };
        }

        function startPowerMeasurement() {
            const cell = document.getElementById('cell-number').value;
            if (!cell || !/^\d{3}$/.test(cell)) {
                LabModals.showCell((cellNumber) => {
                    document.getElementById('cell-number').value = cellNumber;
                    state.cellNumber = cellNumber;
                    startPowerMeasurement(); // Retry after cell number entered
                });
                return;
            }

            state.measurementState = 'power';
            state.powerData = { x: [], y: [] };
            clearPlot('power');
            setMeasuringState(true);
            updateProgress(0, 'Starting power measurement...');

            if (state.offlineMode) {
                mockPowerMeasurement();
                return;
            }

            const api = LabAPI.get();
            if (api && api.start_power_measurement) {
                api.start_power_measurement(JSON.stringify(getParams()), (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) {
                        LabModals.showError('Measurement Failed', r.message);
                        setMeasuringState(false);
                    }
                });
            }
        }

        function startCurrentMeasurement() {
            const cell = document.getElementById('cell-number').value;
            if (!cell || !/^\d{3}$/.test(cell)) {
                LabModals.showCell((cellNumber) => {
                    document.getElementById('cell-number').value = cellNumber;
                    state.cellNumber = cellNumber;
                    LabModals.showPixel(startCurrentMeasurementWithPixel);
                });
                return;
            }
            LabModals.showPixel(startCurrentMeasurementWithPixel);
        }

        function startCurrentMeasurementWithPixel(pixel) {
            state.currentPixel = pixel;
            state.measurementState = 'phase';
            state.phaseData = { x: [], y: [] };
            state.currentData = { x: [], y: [], stats: [] };
            clearPlot('phase');
            clearPlot('current');
            setMeasuringState(true);
            updateProgress(0, 'Phase adjustment...');
            document.getElementById('pixel-label').textContent = 'Pixel: ' + pixel;
            document.getElementById('stats-row').classList.remove('hidden');
            // Trigger Plotly resize after showing stats row
            setTimeout(() => {
                Plotly.Plots.resize('current-plot');
            }, 50);

            if (state.offlineMode) {
                mockPhaseThenCurrentMeasurement(pixel);
                return;
            }

            const params = { ...getParams(), pixel };
            const api = LabAPI.get();
            if (api && api.start_current_measurement) {
                api.start_current_measurement(JSON.stringify(params), (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) {
                        LabModals.showError('Measurement Failed', r.message);
                        setMeasuringState(false);
                    }
                });
            }
        }

        function stopMeasurement() {
            if (state.offlineMode) {
                state.measurementState = 'idle';
                setMeasuringState(false);
                return;
            }
            const api = LabAPI.get();
            if (api && api.stop_measurement) api.stop_measurement(() => {});
            state.measurementState = 'idle';
            setMeasuringState(false);
        }

        function setMeasuringState(measuring) {
            document.getElementById('power-btn').disabled = measuring;
            document.getElementById('current-btn').disabled = measuring;
            document.getElementById('stop-btn').disabled = !measuring;
            document.getElementById('live-btn').disabled = measuring;

            // Disable save button when starting a new measurement
            if (measuring) {
                document.getElementById('save-btn').disabled = true;
            }

            // Disable parameter inputs
            const inputs = document.querySelectorAll('.params-grid input, .mono-controls-inline input');
            inputs.forEach(input => input.disabled = measuring);

            // Disable monochromator control buttons
            const monoButtons = document.querySelectorAll('.mono-controls-inline .btn');
            monoButtons.forEach(btn => btn.disabled = measuring);

            if (!measuring) {
                updateButtonStates();
                document.getElementById('stats-row').classList.add('hidden');
                // Trigger Plotly resize after layout change
                setTimeout(() => {
                    Plotly.Plots.resize('power-plot');
                    Plotly.Plots.resize('current-plot');
                    Plotly.Plots.resize('phase-plot');
                }, 50);
            }
        }

        function updateProgress(percent, status) {
            document.getElementById('progress-fill').style.width = percent + '%';
            document.getElementById('progress-percent').textContent = Math.round(percent) + '%';
            document.getElementById('progress-status').textContent = status;
        }

        // ==================== Plot Updates ====================

        function onPowerProgress(wavelength, power, percent) {
            const powerUW = power * 1e6;
            state.powerData.x.push(wavelength);
            state.powerData.y.push(powerUW);

            const isDark = LabTheme.isDark();
            Plotly.newPlot('power-plot',
                [{ x: state.powerData.x, y: state.powerData.y, mode: 'markers', type: 'scatter',
                   name: 'Power', marker: { color: '#4A90D9', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Power (µW)'),
                plotConfig
            );
            updateProgress(percent, `Measuring at ${wavelength.toFixed(0)} nm`);
        }

        function onCurrentProgress(wavelength, current, percent) {
            const currentNA = current * 1e9;
            state.currentData.x.push(wavelength);
            state.currentData.y.push(currentNA);

            if (state.measurementState === 'phase') {
                state.measurementState = 'current';
            }

            const isDark = LabTheme.isDark();
            Plotly.newPlot('current-plot',
                [{ x: state.currentData.x, y: state.currentData.y, mode: 'markers', type: 'scatter',
                   name: 'Current', marker: { color: '#66bb6a', size: 8 } }],
                getPlotLayout(isDark, 'Wavelength (nm)', 'Current (nA)'),
                plotConfig
            );
            updateProgress(percent, `Measuring at ${wavelength.toFixed(0)} nm`);
        }

        function onPhaseProgress(phase, signal) {
            state.phaseData.x.push(phase);
            state.phaseData.y.push(signal);

            const isDark = LabTheme.isDark();
            Plotly.newPlot('phase-plot',
                [
                    { x: state.phaseData.x, y: state.phaseData.y, mode: 'markers', type: 'scatter',
                      name: 'Measured', marker: { color: '#ff9800', size: 8 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Sine Fit',
                      line: { color: '#e57373', width: 2 } }
                ],
                getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                plotConfig
            );
            updateProgress(0, `Phase adjustment: ${phase.toFixed(0)}°`);
        }

        function onMeasurementComplete(success, message) {
            // Save measurement type before resetting to idle
            const completedMeasurement = state.measurementState;
            state.measurementState = 'idle';
            setMeasuringState(false);

            if (success) {
                updateProgress(100, 'Complete');
                // Enable save button and auto-save based on what measurement just completed
                document.getElementById('save-btn').disabled = false;
                if (completedMeasurement === 'power') savePowerData();
                else if (completedMeasurement === 'current') saveCurrentData();
            } else {
                // Show error message to user
                updateProgress(0, 'Failed');
                if (message && message !== 'Stopped') {
                    LabModals.showError('Measurement Failed', message);
                }
            }
        }

        function onMeasurementStats(stats) {
            state.stats = stats;
            // Store stats for CSV export (one stats object per wavelength point)
            state.currentData.stats.push({
                mean: stats.mean,
                std_dev: stats.std_dev,
                n: stats.n,
                cv_percent: stats.cv_percent
            });
            // Update UI display
            document.getElementById('stats-n').textContent = `${stats.n}/${stats.total}`;
            document.getElementById('stats-cv').textContent = stats.cv_percent.toFixed(1) + '%';
            const badge = document.getElementById('stats-quality');
            badge.textContent = stats.quality;
            badge.className = 'quality-badge quality-' + stats.quality.toLowerCase();
        }

        function onPhaseAdjustmentComplete(data) {
            // Update phase plot with measured data and sine fit
            state.phaseData.x = data.phase_data || [];
            state.phaseData.y = data.signal_data || [];

            const fitX = data.fit_phases || [];
            const fitY = data.fit_signals || [];

            const isDark = LabTheme.isDark();
            Plotly.newPlot('phase-plot',
                [
                    { x: state.phaseData.x, y: state.phaseData.y, mode: 'markers', type: 'scatter',
                      name: 'Measured', marker: { color: '#ff9800', size: 8 } },
                    { x: fitX, y: fitY, mode: 'lines', type: 'scatter', name: 'Sine Fit',
                      line: { color: '#e57373', width: 2 } }
                ],
                getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                plotConfig
            );

            // Update status to show phase is complete
            updateProgress(0, `Phase: ${data.optimal_phase?.toFixed(1) || '--'}° (R² = ${data.r_squared?.toFixed(4) || '--'})`);
        }

        function clearPlot(type) {
            const isDark = LabTheme.isDark();
            if (type === 'power') {
                Plotly.newPlot('power-plot',
                    [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Power',
                       marker: { color: '#4A90D9', size: 8 } }],
                    getPlotLayout(isDark, 'Wavelength (nm)', 'Power (µW)'),
                    plotConfig
                );
            } else if (type === 'current') {
                Plotly.newPlot('current-plot',
                    [{ x: [], y: [], mode: 'markers', type: 'scatter', name: 'Current',
                       marker: { color: '#66bb6a', size: 8 } }],
                    getPlotLayout(isDark, 'Wavelength (nm)', 'Current (nA)'),
                    plotConfig
                );
            } else if (type === 'phase') {
                Plotly.newPlot('phase-plot',
                    [
                        { x: [], y: [], mode: 'markers', type: 'scatter', name: 'Measured',
                          marker: { color: '#ff9800', size: 8 } },
                        { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Sine Fit',
                          line: { color: '#e57373', width: 2 } }
                    ],
                    getPlotLayout(isDark, 'Phase (degrees)', 'Signal (V)'),
                    plotConfig
                );
            }
        }

        // ==================== Live Monitor ====================

        let liveMonitorActive = false;

        function toggleLiveMonitor() {
            if (liveMonitorActive) {
                stopLiveMonitor();
            } else {
                startLiveMonitor();
            }
        }

        function startLiveMonitor() {
            liveMonitorActive = true;
            state.measurementState = 'live_monitor';
            document.getElementById('live-btn').textContent = 'Stop Monitor';
            document.getElementById('live-btn').className = 'btn btn-danger';
            document.getElementById('progress-bar-row').classList.add('hidden');
            document.getElementById('live-reading').classList.remove('hidden');
            document.getElementById('power-btn').disabled = true;
            document.getElementById('current-btn').disabled = true;
            document.getElementById('progress-status').textContent = 'Starting live monitor...';

            if (state.offlineMode) {
                mockLiveMonitor();
                return;
            }

            const api = LabAPI.get();
            if (api && api.start_live_monitor) api.start_live_monitor(() => {});
        }

        function stopLiveMonitor() {
            liveMonitorActive = false;
            state.measurementState = 'idle';
            document.getElementById('live-btn').textContent = 'Live Monitor';
            document.getElementById('live-btn').className = 'btn btn-secondary';
            document.getElementById('progress-bar-row').classList.remove('hidden');
            document.getElementById('live-reading').classList.add('hidden');
            updateButtonStates();
            updateProgress(0, 'Ready');

            if (!state.offlineMode) {
                const api = LabAPI.get();
                if (api && api.stop_live_monitor) api.stop_live_monitor(() => {});
            }
        }

        function onLiveSignalUpdate(currentNA) {
            document.getElementById('live-value').textContent = currentNA.toFixed(2);
        }

        // ==================== Data Export ====================

        function saveData() {
            const hasPower = state.powerData.x.length > 0;
            const hasCurrent = state.currentData.x.length > 0;

            if (!hasPower && !hasCurrent) {
                LabModals.showError('No Data', 'No measurement data to save');
                return;
            }

            // Show the save modal with callback
            LabModals.showSave({ hasPower, hasCurrent }, (type) => {
                if (type === 'power') {
                    savePowerData();
                } else if (type === 'current') {
                    saveCurrentData();
                }
            });
        }

        function savePowerData() {
            let csv = 'Wavelength (nm),Power (uW)\n';
            for (let i = 0; i < state.powerData.x.length; i++) {
                csv += `${state.powerData.x[i].toFixed(1)},${state.powerData.y[i].toFixed(6)}\n`;
            }
            const api = LabAPI.get();
            if (api && api.save_power_data) {
                api.save_power_data(csv, document.getElementById('cell-number').value, (result) => {
                    const r = JSON.parse(result);
                    if (r.success) console.log('Saved:', r.path);
                    else if (r.message !== 'Cancelled') LabModals.showError('Save Failed', r.message);
                });
            }
        }

        function saveCurrentData() {
            // Include measurement statistics in CSV (matches settings.DATA_EXPORT_CONFIG)
            let csv = 'Wavelength (nm),Current_mean (nA),Current_std (nA),n,CV_percent\n';
            for (let i = 0; i < state.currentData.x.length; i++) {
                const wavelength = state.currentData.x[i];
                const current = state.currentData.y[i];
                const stats = state.currentData.stats[i] || {};
                const std_dev = stats.std_dev !== undefined ? (stats.std_dev * 1e9).toFixed(6) : '0';
                const n = stats.n || 0;
                const cv = stats.cv_percent !== undefined ? stats.cv_percent.toFixed(2) : '0';
                csv += `${wavelength.toFixed(1)},${current.toFixed(6)},${std_dev},${n},${cv}\n`;
            }
            const api = LabAPI.get();
            if (api && api.save_current_data) {
                api.save_current_data(csv, document.getElementById('cell-number').value, state.currentPixel, (result) => {
                    const r = JSON.parse(result);
                    if (r.success) console.log('Saved:', r.path);
                    else if (r.message !== 'Cancelled') LabModals.showError('Save Failed', r.message);
                });
            }
        }

        // ==================== Mock Measurements ====================

        function mockPowerMeasurement() {
            const params = getParams();
            let wavelength = params.start_wavelength;
            const end = params.end_wavelength;
            const step = params.step_size;
            const total = Math.ceil((end - wavelength) / step) + 1;
            let count = 0;

            // Open shutter at start
            state.shutterOpen = true;
            updateMonochromatorDisplay();

            const interval = setInterval(() => {
                if (state.measurementState !== 'power' || wavelength > end) {
                    clearInterval(interval);
                    if (state.measurementState === 'power') {
                        state.shutterOpen = false;
                        updateMonochromatorDisplay();
                        onMeasurementComplete(true, 'Complete');
                    }
                    return;
                }
                const power = 2e-6 * Math.exp(-Math.pow((wavelength - 550) / 100, 2)) * (0.9 + 0.2 * Math.random());
                count++;

                // Update monochromator display
                state.wavelength = wavelength;
                updateMonochromatorDisplay();

                onPowerProgress(wavelength, power, (count / total) * 100);
                wavelength += step;
            }, 100);
        }

        function mockPhaseThenCurrentMeasurement(pixel) {
            // Set to 532nm for phase adjustment, open shutter
            state.wavelength = 532;
            state.shutterOpen = true;
            updateMonochromatorDisplay();

            // Generate phase data with noise
            const phaseData = [];
            const signalData = [];
            const optimalPhase = 45;  // Mock optimal phase
            const amplitude = 0.4;
            const offset = 0.5;

            for (let phase = 0; phase <= 360; phase += 15) {
                const signal = offset + amplitude * Math.sin((phase - optimalPhase) * Math.PI / 180) + 0.02 * (Math.random() - 0.5);
                phaseData.push(phase);
                signalData.push(signal);
                onPhaseProgress(phase, signal);
            }

            // Generate smooth sine fit curve
            const fitPhases = [];
            const fitSignals = [];
            for (let phase = 0; phase <= 360; phase += 5) {
                fitPhases.push(phase);
                fitSignals.push(offset + amplitude * Math.sin((phase - optimalPhase) * Math.PI / 180));
            }

            // Simulate delay before showing fit and starting current measurement
            setTimeout(() => {
                if (state.measurementState === 'idle') return;

                // Send complete phase adjustment data with fit
                onPhaseAdjustmentComplete({
                    phase_data: phaseData,
                    signal_data: signalData,
                    fit_phases: fitPhases,
                    fit_signals: fitSignals,
                    optimal_phase: optimalPhase,
                    r_squared: 0.9876
                });

                // Start current measurement
                state.measurementState = 'current';
                mockCurrentMeasurement();
            }, 500);
        }

        function mockCurrentMeasurement() {
            const params = getParams();
            let wavelength = params.start_wavelength;
            const end = params.end_wavelength;
            const step = params.step_size;
            const total = Math.ceil((end - wavelength) / step) + 1;
            let count = 0;

            const interval = setInterval(() => {
                if (state.measurementState !== 'current' || wavelength > end) {
                    clearInterval(interval);
                    if (state.measurementState === 'current') {
                        state.shutterOpen = false;
                        updateMonochromatorDisplay();
                        onMeasurementComplete(true, 'Complete');
                    }
                    return;
                }
                const bandgap = 750;
                let current;
                if (wavelength < bandgap) {
                    current = 2e-9 * (1 - Math.exp(-(wavelength - 350) / 50)) * (0.9 + 0.2 * Math.random());
                } else {
                    current = 2e-9 * Math.exp(-(wavelength - bandgap) / 30) * (0.9 + 0.2 * Math.random());
                }
                count++;

                // Update monochromator display
                state.wavelength = wavelength;
                updateMonochromatorDisplay();

                // Stats use Amps (same as real measurements) - conversion to nA happens in saveCurrentData
                // Simulate realistic CV variation (0.5-8%) - no outlier rejection (pedagogical choice)
                const cv = 0.5 + Math.random() * 7.5;  // Random CV between 0.5-8%
                const std_dev = current * (cv / 100);
                const quality = cv < 1.0 ? 'Excellent' : cv < 5.0 ? 'Good' : cv < 10.0 ? 'Fair' : 'Check';
                onMeasurementStats({
                    mean: current,
                    std_dev: std_dev,
                    n: 5, total: 5, outliers: 0,
                    cv_percent: cv, quality: quality
                });

                onCurrentProgress(wavelength, current, (count / total) * 100);
                wavelength += step;
            }, 150);
        }

        function mockLiveMonitor() {
            // Set to 532nm for live monitor, open shutter
            state.wavelength = 532;
            state.shutterOpen = true;
            updateMonochromatorDisplay();
            document.getElementById('progress-status').textContent = 'Live monitoring at 532 nm';

            const mockInterval = setInterval(() => {
                if (!liveMonitorActive) {
                    clearInterval(mockInterval);
                    state.shutterOpen = false;
                    updateMonochromatorDisplay();
                    return;
                }
                onLiveSignalUpdate(1.5 + 0.5 * Math.random());
            }, 500);
        }

        // ==================== Stability Tests ====================

        function initStabilityPlots() {
            const isDark = LabTheme.isDark();

            // Time series plot
            Plotly.newPlot('stability-time-plot',
                [
                    { x: [], y: [], mode: 'lines+markers', type: 'scatter', name: 'Measured',
                      line: { color: '#4A90D9' }, marker: { size: 6 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Mean',
                      line: { color: '#e57373', dash: 'dash', width: 2 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: '+1σ',
                      line: { color: '#ffb74d', dash: 'dot', width: 1 }, showlegend: false },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: '-1σ',
                      line: { color: '#ffb74d', dash: 'dot', width: 1 }, showlegend: false }
                ],
                getPlotLayout(isDark, 'Time (s)', 'Value'),
                plotConfig
            );

            // Histogram plot
            Plotly.newPlot('stability-hist-plot',
                [{ x: [], type: 'histogram', name: 'Distribution',
                   marker: { color: '#4A90D9' } }],
                {
                    ...getPlotLayout(isDark, 'Value', 'Count'),
                    bargap: 0.05
                },
                plotConfig
            );
        }

        function onStabilityTypeChange() {
            const testType = document.querySelector('input[name="stability-type"]:checked').value;
            state.stability.testType = testType;
        }

        function getStabilityParams() {
            return {
                type: state.stability.testType,
                wavelength: parseFloat(document.getElementById('stability-wavelength').value),
                duration: parseFloat(document.getElementById('stability-duration').value),
                interval: parseFloat(document.getElementById('stability-interval').value),
                pixel: state.stability.pixel || 1
            };
        }

        function startStabilityTest() {
            const testType = document.querySelector('input[name="stability-type"]:checked').value;
            state.stability.testType = testType;

            // Validate wavelength first
            const wavelength = parseFloat(document.getElementById('stability-wavelength').value);
            if (isNaN(wavelength) || wavelength < 200 || wavelength > 1200) {
                LabModals.showError('Invalid Wavelength', 'Enter wavelength between 200-1200 nm');
                return;
            }

            // For current tests, show pixel modal first
            if (testType === 'current') {
                LabModals.showPixel(startStabilityTestWithPixel);
            } else {
                startStabilityTestWithPixel(null);
            }
        }

        function startStabilityTestWithPixel(pixel) {
            if (pixel !== null) {
                state.stability.pixel = pixel;
                document.getElementById('pixel-label').textContent = 'Pixel: ' + pixel;
            }

            const params = getStabilityParams();

            // Reset state
            state.stability.running = true;
            state.stability.data = { times: [], values: [] };
            state.stability.stats = null;
            state.stability.startTime = Date.now();

            // Update UI
            setStabilityTestState(true);
            updateStabilityProgress(0, 'Starting test...');
            clearStabilityStats();

            if (state.offlineMode) {
                mockStabilityTest(params);
                return;
            }

            const api = LabAPI.get();
            if (api && api.start_stability_test) {
                api.start_stability_test(JSON.stringify(params), (result) => {
                    const r = JSON.parse(result);
                    if (!r.success) {
                        LabModals.showError('Test Failed', r.message);
                        setStabilityTestState(false);
                    } else if (r.phase === 'adjusting') {
                        // Current test - show phase adjustment status
                        updateStabilityProgress(0, 'Adjusting phase (locking to chopper)...');
                    }
                });
            }
        }

        function stopStabilityTest() {
            state.stability.running = false;

            if (!state.offlineMode) {
                const api = LabAPI.get();
                if (api && api.stop_stability_test) api.stop_stability_test(() => {});
            }

            setStabilityTestState(false);
            updateStabilityProgress(0, 'Stopped');
        }

        function setStabilityTestState(running) {
            document.getElementById('stability-start-btn').disabled = running;
            document.getElementById('stability-stop-btn').disabled = !running;

            // Disable inputs during test
            const inputs = document.querySelectorAll('#tab-stability .config-field input, #tab-stability input[type="radio"]');
            inputs.forEach(input => input.disabled = running);

            // Disable monochromator controls during test (shared across tabs)
            document.getElementById('wavelength-input').disabled = running;
            document.querySelectorAll('.mono-controls-inline .btn').forEach(btn => btn.disabled = running);

            if (!running && state.stability.data.times.length > 0) {
                document.getElementById('stability-save-btn').disabled = false;
            }
        }

        function updateStabilityProgress(percent, status) {
            document.getElementById('stability-progress-fill').style.width = percent + '%';
            document.getElementById('stability-progress-percent').textContent = Math.round(percent) + '%';
            document.getElementById('stability-status').textContent = status;
        }

        function onStabilityProgress(timestamp, value) {
            state.stability.data.times.push(timestamp);
            state.stability.data.values.push(value);

            // Calculate statistics
            const stats = calculateStabilityStats(state.stability.data.values);
            state.stability.stats = stats;

            // Update plots
            updateStabilityPlots();

            // Update stats display
            updateStabilityStatsDisplay(stats);

            // Update progress
            const params = getStabilityParams();
            const elapsed = timestamp;
            const total = params.duration * 60;
            const percent = Math.min(100, (elapsed / total) * 100);
            updateStabilityProgress(percent, `Measuring... (${state.stability.data.times.length} points)`);
        }

        function calculateStabilityStats(values) {
            if (values.length === 0) return null;

            const n = values.length;
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;
            const std = Math.sqrt(variance);
            const min = Math.min(...values);
            const max = Math.max(...values);

            return {
                mean: mean,
                std: std,
                cv_percent: (std / Math.abs(mean)) * 100,
                min: min,
                max: max,
                range: max - min,
                count: n
            };
        }

        function updateStabilityPlots() {
            const isDark = LabTheme.isDark();
            const times = state.stability.data.times;
            const rawValues = state.stability.data.values;
            const stats = state.stability.stats;

            // Convert to display units (µW or nA)
            const isPower = state.stability.testType === 'power';
            const multiplier = isPower ? 1e6 : 1e9;
            const values = rawValues.map(v => v * multiplier);

            // Prepare mean and sigma lines (also converted)
            let meanLine = [], plusSigma = [], minusSigma = [];
            if (stats && times.length > 0) {
                const meanVal = stats.mean * multiplier;
                const stdVal = stats.std * multiplier;
                meanLine = [{ x: [times[0], times[times.length - 1]], y: [meanVal, meanVal] }];
                plusSigma = [{ x: [times[0], times[times.length - 1]], y: [meanVal + stdVal, meanVal + stdVal] }];
                minusSigma = [{ x: [times[0], times[times.length - 1]], y: [meanVal - stdVal, meanVal - stdVal] }];
            }

            // Determine y-axis label based on test type
            const yLabel = isPower ? 'Power (µW)' : 'Current (nA)';

            // Time series plot with 2 decimal places
            const timeLayout = getPlotLayout(isDark, 'Time (s)', yLabel);
            timeLayout.yaxis.tickformat = '.2f';

            Plotly.react('stability-time-plot',
                [
                    { x: times, y: values, mode: 'lines+markers', type: 'scatter', name: 'Measured',
                      line: { color: '#4A90D9' }, marker: { size: 6 } },
                    { x: meanLine[0]?.x || [], y: meanLine[0]?.y || [], mode: 'lines', type: 'scatter', name: 'Mean',
                      line: { color: '#e57373', dash: 'dash', width: 2 } },
                    { x: plusSigma[0]?.x || [], y: plusSigma[0]?.y || [], mode: 'lines', type: 'scatter', name: '±1σ',
                      line: { color: '#ffb74d', dash: 'dot', width: 1 } },
                    { x: minusSigma[0]?.x || [], y: minusSigma[0]?.y || [], mode: 'lines', type: 'scatter', name: '-1σ',
                      line: { color: '#ffb74d', dash: 'dot', width: 1 }, showlegend: false }
                ],
                timeLayout,
                plotConfig
            );

            // Histogram plot with 2 decimal places and more bottom margin
            const histLayout = getPlotLayout(isDark, yLabel, 'Count');
            histLayout.xaxis.tickformat = '.2f';
            histLayout.margin = { ...histLayout.margin, b: 60, l: 50 };
            histLayout.bargap = 0.05;

            Plotly.react('stability-hist-plot',
                [{ x: values, type: 'histogram', name: 'Distribution',
                   marker: { color: '#4A90D9' },
                   nbinsx: Math.min(20, Math.max(5, Math.floor(values.length / 2))) }],
                histLayout,
                plotConfig
            );
        }

        function updateStabilityStatsDisplay(stats) {
            if (!stats) return;

            const isPower = state.stability.testType === 'power';
            const unit = isPower ? ' µW' : ' nA';
            const multiplier = isPower ? 1e6 : 1e9;

            document.getElementById('stability-mean').textContent =
                (stats.mean * multiplier).toFixed(3) + unit;
            document.getElementById('stability-std').textContent =
                (stats.std * multiplier).toFixed(3) + unit;

            const cvEl = document.getElementById('stability-cv');
            cvEl.textContent = stats.cv_percent.toFixed(2) + '%';
            cvEl.className = 'stability-stat-value cv';
            if (stats.cv_percent < 1.0) cvEl.classList.add('excellent');
            else if (stats.cv_percent < 3.0) cvEl.classList.add('good');
            else cvEl.classList.add('poor');

            document.getElementById('stability-count').textContent = stats.count;
            document.getElementById('stability-range').textContent =
                (stats.min * multiplier).toFixed(3) + ' - ' + (stats.max * multiplier).toFixed(3) + unit;
        }

        function clearStabilityStats() {
            document.getElementById('stability-mean').textContent = '--';
            document.getElementById('stability-std').textContent = '--';
            document.getElementById('stability-cv').textContent = '--%';
            document.getElementById('stability-cv').className = 'stability-stat-value cv';
            document.getElementById('stability-count').textContent = '0';
            document.getElementById('stability-range').textContent = '--';

            // Clear plots
            initStabilityPlots();
        }

        function onStabilityComplete(success, message) {
            state.stability.running = false;
            setStabilityTestState(false);

            if (success) {
                const count = state.stability.data.times.length;
                updateStabilityProgress(100, `Complete (${count} measurements)`);
            } else {
                updateStabilityProgress(0, message || 'Failed');
                if (message && message !== 'Stopped') {
                    LabModals.showError('Test Failed', message);
                }
            }
        }

        function saveStabilityData() {
            const stats = state.stability.stats;
            const params = getStabilityParams();
            const isPower = state.stability.testType === 'power';
            const unit = isPower ? 'W' : 'A';
            const unitDisplay = isPower ? 'uW' : 'nA';
            const multiplier = isPower ? 1e6 : 1e9;

            // Build CSV with header comments
            let csv = `# Stability Test Results\n`;
            csv += `# Type: ${state.stability.testType}\n`;
            csv += `# Wavelength: ${params.wavelength} nm\n`;
            csv += `# Duration: ${params.duration} min\n`;
            csv += `# Interval: ${params.interval} sec\n`;
            if (stats) {
                csv += `# Mean: ${(stats.mean * multiplier).toFixed(6)} ${unitDisplay}\n`;
                csv += `# Std Dev: ${(stats.std * multiplier).toFixed(6)} ${unitDisplay}\n`;
                csv += `# CV: ${stats.cv_percent.toFixed(4)}%\n`;
                csv += `# Count: ${stats.count}\n`;
            }
            csv += `#\n`;
            csv += `Time (s),Value (${unit}),Value (${unitDisplay})\n`;

            for (let i = 0; i < state.stability.data.times.length; i++) {
                const t = state.stability.data.times[i];
                const v = state.stability.data.values[i];
                csv += `${t.toFixed(2)},${v.toExponential(6)},${(v * multiplier).toFixed(6)}\n`;
            }

            const api = LabAPI.get();
            if (api && api.save_stability_data) {
                api.save_stability_data(csv, params.wavelength, state.stability.testType, (result) => {
                    const r = JSON.parse(result);
                    if (r.success) console.log('Saved:', r.path);
                    else if (r.message !== 'Cancelled') LabModals.showError('Save Failed', r.message);
                });
            }
        }

        // ==================== Mock Stability Test ====================

        function mockStabilityTest(params) {
            const intervalMs = params.interval * 1000;
            const durationMs = params.duration * 60 * 1000;
            const isPower = params.type === 'power';

            // Base value with some noise
            const baseValue = isPower ? 2.5e-6 : 1.8e-9;  // 2.5 µW or 1.8 nA
            const noiseLevel = baseValue * 0.02;  // 2% noise

            // Open shutter and set wavelength
            state.wavelength = params.wavelength;
            state.shutterOpen = true;
            updateMonochromatorDisplay();

            let elapsed = 0;

            const mockInterval = setInterval(() => {
                if (!state.stability.running || elapsed >= durationMs) {
                    clearInterval(mockInterval);
                    state.shutterOpen = false;
                    updateMonochromatorDisplay();
                    if (state.stability.running) {
                        onStabilityComplete(true, 'Complete');
                    }
                    return;
                }

                elapsed += intervalMs;
                const timestamp = elapsed / 1000;
                const value = baseValue + (Math.random() - 0.5) * 2 * noiseLevel;

                onStabilityProgress(timestamp, value);
            }, intervalMs);
        }

        // ==================== EQE Analysis (Staff Mode) ====================

        // Physical constants for EQE calculation
        const PLANCK = 6.62607015e-34;  // J·s
        const SPEED_OF_LIGHT = 2.99792458e8;  // m/s
        const ELECTRON_CHARGE = 1.602176634e-19;  // C

        // Keyboard shortcuts for staff mode
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'E') {
                e.preventDefault();
                toggleAnalysisPanel();
            } else if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                toggleDebugMode();
            }
        });

        function toggleDebugMode() {
            const api = LabAPI.get();
            if (api && api.toggle_debug_mode) {
                api.toggle_debug_mode((result) => {
                    const r = JSON.parse(result);
                    state.debugMode = r.enabled;
                    if (r.enabled) {
                        LabModals.showInfo('Debug Mode ENABLED',
                            'Technical output (samples, SDK calls) now visible in console.\n\nPress Ctrl+Shift+D again to disable.');
                    } else {
                        LabModals.showInfo('Debug Mode DISABLED', 'Debug output turned off.');
                    }
                });
            } else if (state.offlineMode) {
                state.debugMode = !state.debugMode;
                if (state.debugMode) {
                    LabModals.showInfo('Debug Mode ENABLED', 'Offline mode - no effect on console output.');
                } else {
                    LabModals.showInfo('Debug Mode DISABLED', 'Debug output turned off.');
                }
            }
        }

        function toggleAnalysisPanel() {
            state.analysis.visible = !state.analysis.visible;
            const tabBtn = document.getElementById('analysis-tab-btn');

            if (state.analysis.visible) {
                // Show the tab and switch to it
                tabBtn.style.display = '';
                switchTab('analysis');
            } else {
                // Hide the tab and switch back to measurement
                tabBtn.style.display = 'none';
                switchTab('measurement');
            }
        }

        function initEQEPlot() {
            const isDark = LabTheme.isDark();
            Plotly.newPlot('eqe-plot',
                [
                    { x: [], y: [], mode: 'lines+markers', type: 'scatter', name: 'EQE',
                      line: { color: '#4A90D9', width: 2 }, marker: { size: 6 } },
                    { x: [], y: [], mode: 'lines', type: 'scatter', name: 'Peak',
                      line: { color: '#e57373', dash: 'dash', width: 1 } }
                ],
                {
                    ...getPlotLayout(isDark, 'Wavelength (nm)', 'EQE (%)'),
                    yaxis: {
                        ...getPlotLayout(isDark, '', '').yaxis,
                        title: 'EQE (%)',
                        range: [0, 100]
                    }
                },
                plotConfig
            );
        }

        function updateSessionDataButton() {
            const hasPower = state.powerData.x.length > 0;
            const hasCurrent = state.currentData.x.length > 0;
            document.getElementById('use-power-session-btn').disabled = !hasPower;
            document.getElementById('use-current-session-btn').disabled = !hasCurrent;
        }

        function updateCalculateButton() {
            const hasPower = state.analysis.powerData !== null;
            const hasCurrent = state.analysis.currentData !== null;
            document.getElementById('calculate-eqe-btn').disabled = !(hasPower && hasCurrent);
        }

        function usePowerSession() {
            if (state.powerData.x.length === 0) {
                setAnalysisStatus('No power data in session', 'error');
                return;
            }

            state.analysis.powerData = {
                wavelengths: [...state.powerData.x],
                values: state.powerData.y.map(p => p * 1e-6)  // µW -> W
            };

            document.getElementById('power-file-status').textContent = `Session (${state.powerData.x.length} pts)`;
            document.getElementById('power-file-status').classList.add('loaded');

            updateCalculateButton();
            setAnalysisStatus('Power data loaded from session');
        }

        function useCurrentSession() {
            if (state.currentData.x.length === 0) {
                setAnalysisStatus('No current data in session', 'error');
                return;
            }

            state.analysis.currentData = {
                wavelengths: [...state.currentData.x],
                values: state.currentData.y.map(c => c * 1e-9)  // nA -> A
            };

            document.getElementById('current-file-status').textContent = `Session (${state.currentData.x.length} pts)`;
            document.getElementById('current-file-status').classList.add('loaded');

            updateCalculateButton();
            setAnalysisStatus('Current data loaded from session');
        }

        function loadPowerCSV() {
            const input = document.getElementById('power-file-input');
            input.value = '';  // Reset so same file can be selected again
            input.click();
        }

        function loadCurrentCSV() {
            const input = document.getElementById('current-file-input');
            input.value = '';  // Reset so same file can be selected again
            input.click();
        }

        function onPowerFileSelected(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = parseCSV(e.target.result);
                    state.analysis.powerData = data;
                    document.getElementById('power-file-status').textContent = file.name;
                    document.getElementById('power-file-status').classList.add('loaded');
                    updateCalculateButton();
                    setAnalysisStatus(`Power data loaded (${data.wavelengths.length} points)`, 'success');
                } catch (err) {
                    setAnalysisStatus('Failed to parse power CSV: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function onCurrentFileSelected(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = parseCSV(e.target.result);
                    state.analysis.currentData = data;
                    document.getElementById('current-file-status').textContent = file.name;
                    document.getElementById('current-file-status').classList.add('loaded');
                    updateCalculateButton();
                    setAnalysisStatus(`Current data loaded (${data.wavelengths.length} points)`, 'success');
                } catch (err) {
                    setAnalysisStatus('Failed to parse current CSV: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function parseCSV(content) {
            const lines = content.trim().split('\n');
            const wavelengths = [];
            const values = [];

            // Skip header line and comment lines
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line || line.startsWith('#') || line.startsWith('Wavelength')) continue;

                const parts = line.split(',');
                if (parts.length >= 2) {
                    const wl = parseFloat(parts[0]);
                    const val = parseFloat(parts[1]);
                    if (!isNaN(wl) && !isNaN(val)) {
                        wavelengths.push(wl);
                        values.push(val);
                    }
                }
            }

            if (wavelengths.length === 0) {
                throw new Error('No valid data found');
            }

            return { wavelengths, values };
        }

        function calculateEQE() {
            const power = state.analysis.powerData;
            const current = state.analysis.currentData;

            if (!power || !current) {
                setAnalysisStatus('Missing power or current data', 'error');
                return;
            }

            try {
                // Interpolate power to match current wavelengths
                const eqeWavelengths = [];
                const eqeValues = [];

                for (let i = 0; i < current.wavelengths.length; i++) {
                    const wl = current.wavelengths[i];
                    const I = current.values[i];  // Current in A

                    // Find interpolated power at this wavelength
                    const P = interpolate(power.wavelengths, power.values, wl);
                    if (P === null || P <= 0) continue;

                    // EQE = (I * h * c) / (q * P * λ)
                    // λ must be in meters
                    const lambda_m = wl * 1e-9;
                    const eqe = (Math.abs(I) * PLANCK * SPEED_OF_LIGHT) / (ELECTRON_CHARGE * P * lambda_m);
                    const eqePercent = eqe * 100;

                    // Sanity check
                    if (eqePercent >= 0 && eqePercent <= 150) {
                        eqeWavelengths.push(wl);
                        eqeValues.push(eqePercent);
                    }
                }

                if (eqeWavelengths.length === 0) {
                    setAnalysisStatus('No valid EQE values calculated', 'error');
                    return;
                }

                state.analysis.eqeData = { wavelengths: eqeWavelengths, eqe: eqeValues };

                // Calculate metrics
                const peakEQE = Math.max(...eqeValues);
                const peakIndex = eqeValues.indexOf(peakEQE);
                const peakWavelength = eqeWavelengths[peakIndex];

                // Find bandgap edge (50% of peak on red side)
                const threshold = peakEQE * 0.5;
                let bandgapWavelength = null;
                for (let i = peakIndex; i < eqeWavelengths.length - 1; i++) {
                    if (eqeValues[i] >= threshold && eqeValues[i + 1] < threshold) {
                        // Linear interpolation to find exact crossing
                        const x1 = eqeWavelengths[i], x2 = eqeWavelengths[i + 1];
                        const y1 = eqeValues[i], y2 = eqeValues[i + 1];
                        bandgapWavelength = x1 + (threshold - y1) * (x2 - x1) / (y2 - y1);
                        break;
                    }
                }

                state.analysis.metrics = {
                    peakEQE: peakEQE,
                    peakWavelength: peakWavelength,
                    bandgapWavelength: bandgapWavelength,
                    bandgapEV: bandgapWavelength ? 1240 / bandgapWavelength : null,
                    dataPoints: eqeWavelengths.length
                };

                // Update plot
                updateEQEPlot();

                // Update metrics display
                updateMetricsDisplay();

                setAnalysisStatus('EQE calculated successfully', 'success');

            } catch (err) {
                setAnalysisStatus('Calculation error: ' + err.message, 'error');
            }
        }

        function interpolate(xArray, yArray, x) {
            if (x < xArray[0] || x > xArray[xArray.length - 1]) return null;

            for (let i = 0; i < xArray.length - 1; i++) {
                if (x >= xArray[i] && x <= xArray[i + 1]) {
                    const t = (x - xArray[i]) / (xArray[i + 1] - xArray[i]);
                    return yArray[i] + t * (yArray[i + 1] - yArray[i]);
                }
            }
            return null;
        }

        function updateEQEPlot() {
            const isDark = LabTheme.isDark();
            const data = state.analysis.eqeData;
            const metrics = state.analysis.metrics;

            // Peak line data
            const peakX = data.wavelengths.length > 0 ?
                [data.wavelengths[0], data.wavelengths[data.wavelengths.length - 1]] : [];
            const peakY = metrics ? [metrics.peakEQE, metrics.peakEQE] : [];

            Plotly.react('eqe-plot',
                [
                    { x: data.wavelengths, y: data.eqe, mode: 'lines+markers', type: 'scatter', name: 'EQE',
                      line: { color: '#4A90D9', width: 2 }, marker: { size: 6 } },
                    { x: peakX, y: peakY, mode: 'lines', type: 'scatter', name: `Peak: ${metrics?.peakEQE?.toFixed(1)}%`,
                      line: { color: '#e57373', dash: 'dash', width: 1 } }
                ],
                {
                    ...getPlotLayout(isDark, 'Wavelength (nm)', 'EQE (%)'),
                    yaxis: {
                        ...getPlotLayout(isDark, '', '').yaxis,
                        title: 'EQE (%)',
                        range: [0, Math.max(100, (metrics?.peakEQE || 0) * 1.1)]
                    }
                },
                plotConfig
            );
        }

        function updateMetricsDisplay() {
            const m = state.analysis.metrics;
            if (!m) return;

            document.getElementById('metric-peak-eqe').textContent = m.peakEQE.toFixed(1) + '%';
            document.getElementById('metric-peak-wavelength').textContent = `at ${m.peakWavelength.toFixed(0)} nm`;

            if (m.bandgapWavelength) {
                document.getElementById('metric-bandgap').textContent = `~${m.bandgapWavelength.toFixed(0)} nm`;
                document.getElementById('metric-bandgap-ev').textContent = `(${m.bandgapEV.toFixed(2)} eV)`;
            } else {
                document.getElementById('metric-bandgap').textContent = 'N/A';
                document.getElementById('metric-bandgap-ev').textContent = '';
            }

            document.getElementById('metric-datapoints').textContent = m.dataPoints;
        }

        function setAnalysisStatus(message, type) {
            const el = document.getElementById('analysis-status');
            el.textContent = message;
            el.className = 'progress-status analysis-status-text' + (type ? ' ' + type : '');
        }

        // Global callbacks for Python
        window.onDeviceStatusChanged = onDeviceStatusChanged;
        window.onMonochromatorStateChanged = onMonochromatorStateChanged;
        window.onPowerProgress = onPowerProgress;
        window.onCurrentProgress = onCurrentProgress;
        window.onPhaseProgress = onPhaseProgress;
        window.onPhaseAdjustmentComplete = onPhaseAdjustmentComplete;
        window.onMeasurementComplete = onMeasurementComplete;
        window.onMeasurementStats = onMeasurementStats;
        window.onLiveSignalUpdate = onLiveSignalUpdate;
        window.onStabilityProgress = onStabilityProgress;
        window.onStabilityComplete = onStabilityComplete;
    </script>
</body>
</html>
